<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>Archery Range</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body { overflow: hidden; background: #000; font-family: 'Segoe UI', sans-serif; touch-action: none; overscroll-behavior: none; }
  canvas { display: block; }
  #hud {
    position: fixed; top: 0; left: 0; width: 100%; pointer-events: none; z-index: 10;
    display: flex; justify-content: space-between; padding: 20px 30px;
  }
  #hud div { color: #fff; font-size: 22px; text-shadow: 0 2px 6px rgba(0,0,0,0.7); }
  #score { text-align: center; flex: 1; font-size: 28px !important; font-weight: bold; }
  #round-display { color: #aaa !important; font-size: 16px !important; text-align: center; }
  #crosshair {
    position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
    width: 30px; height: 30px; pointer-events: none; z-index: 10;
  }
  #crosshair::before, #crosshair::after {
    content: ''; position: absolute; background: rgba(255,255,255,0.8);
  }
  #crosshair::before { width: 2px; height: 100%; left: 50%; transform: translateX(-50%); }
  #crosshair::after { height: 2px; width: 100%; top: 50%; transform: translateY(-50%); }
  #crosshair .dot {
    position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
    width: 4px; height: 4px; background: #ff4444; border-radius: 50%;
  }
  /* Power bar */
  #power-bar-container {
    position: fixed; top: calc(50% + 30px); left: 50%; transform: translateX(-50%);
    width: 80px; height: 8px; background: rgba(0,0,0,0.5); border-radius: 4px;
    pointer-events: none; z-index: 10; display: none; border: 1px solid rgba(255,255,255,0.3);
  }
  #power-bar-fill {
    height: 100%; width: 0%; border-radius: 3px;
    transition: width 0.05s linear;
  }
  /* Wind compass */
  #wind-compass {
    position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%);
    pointer-events: none; z-index: 10;
  }
  #wind-label {
    position: fixed; bottom: 5px; left: 50%; transform: translateX(-50%);
    color: #fff; font-size: 14px; text-shadow: 0 1px 4px rgba(0,0,0,0.7);
    pointer-events: none; z-index: 10; text-align: center; white-space: nowrap;
  }
  /* Slow-mo vignette */
  #slowmo-vignette {
    position: fixed; top: 0; left: 0; width: 100%; height: 100%;
    pointer-events: none; z-index: 9; opacity: 0;
    background: radial-gradient(ellipse at center, transparent 50%, rgba(0,0,0,0.6) 100%);
    transition: opacity 0.3s;
  }
  #bonus-popup {
    position: fixed; top: 40%; left: 50%; transform: translate(-50%, -50%);
    color: #ffdd00; font-size: 36px; font-weight: bold; pointer-events: none;
    text-shadow: 0 0 20px rgba(255,200,0,0.8); opacity: 0; z-index: 10;
    transition: opacity 0.2s;
  }
  #hit-popup {
    position: fixed; top: 45%; left: 50%; transform: translate(-50%, -50%);
    color: #fff; font-size: 28px; font-weight: bold; pointer-events: none;
    text-shadow: 0 0 10px rgba(255,255,255,0.5); opacity: 0; z-index: 10;
    transition: opacity 0.2s;
  }
  #game-over {
    position: fixed; top: 0; left: 0; width: 100%; height: 100%;
    background: rgba(0,0,0,0.85); display: none; z-index: 20;
    flex-direction: column; align-items: center; justify-content: center; color: #fff;
  }
  #game-over h1 { font-size: 52px; margin-bottom: 10px; }
  #game-over .final-score { font-size: 72px; color: #ffdd00; margin: 20px 0; }
  #game-over .breakdown { font-size: 20px; color: #aaa; margin-bottom: 30px; text-align: center; line-height: 1.6; }
  #game-over button {
    padding: 15px 40px; font-size: 22px; background: #ff4444; color: #fff;
    border: none; border-radius: 8px; cursor: pointer; pointer-events: all;
    transition: background 0.2s;
  }
  #game-over button:hover { background: #ff6666; }
  #start-screen {
    position: fixed; top: 0; left: 0; width: 100%; height: 100%;
    background: rgba(0,0,0,0.9); z-index: 20;
    display: flex; flex-direction: column; align-items: center; justify-content: center; color: #fff;
  }
  #start-screen h1 { font-size: 56px; margin-bottom: 10px; }
  #start-screen p { font-size: 20px; color: #aaa; margin-bottom: 30px; text-align: center; }
  #start-screen button {
    padding: 15px 40px; font-size: 22px; background: #4CAF50; color: #fff;
    border: none; border-radius: 8px; cursor: pointer;
    transition: background 0.2s;
  }
  #start-screen button:hover { background: #66BB6A; }
  .arrow-icons { display: flex; gap: 4px; align-items: center; }
  .arrow-icon {
    width: 3px; height: 18px; background: #fff; position: relative; display: inline-block;
  }
  .arrow-icon::after {
    content: ''; position: absolute; top: -5px; left: 50%; transform: translateX(-50%);
    border-left: 4px solid transparent; border-right: 4px solid transparent;
    border-bottom: 6px solid #ff4444;
  }
  .arrow-icon.used { opacity: 0.2; }

  /* Mobile responsive */
  @media (pointer: coarse) {
    #crosshair { width: 50px; height: 50px; }
    #crosshair .dot { width: 8px; height: 8px; }
    #crosshair::before { width: 3px; }
    #crosshair::after { height: 3px; }
    #hud div { font-size: 18px; }
    #score { font-size: 24px !important; }
    #power-bar-container { width: 100px; height: 12px; top: calc(50% + 40px); }
    #start-screen h1 { font-size: 40px; }
    #start-screen p { font-size: 16px; padding: 0 20px; }
    #game-over h1 { font-size: 40px; }
    #game-over .final-score { font-size: 56px; }
    #game-over .breakdown { font-size: 16px; padding: 0 20px; }
    #wind-label { font-size: 12px; }
  }
</style>
</head>
<body>

<div id="start-screen">
  <h1>Archery Range</h1>
  <p>15 arrows. Hold to draw, release to fire.<br>Aim true. Hit the bullseye.</p>
  <button id="start-btn" onclick="startGame()">Click to Play</button>
</div>

<div id="hud">
  <div id="arrows-left"></div>
  <div style="flex:1; text-align:center;">
    <div id="score">0</div>
    <div id="round-display"></div>
  </div>
  <div id="best">Best: 0</div>
</div>

<div id="crosshair"><div class="dot"></div></div>
<div id="power-bar-container"><div id="power-bar-fill"></div></div>
<canvas id="wind-compass" width="60" height="60"></canvas>
<div id="wind-label"></div>
<div id="slowmo-vignette"></div>
<div id="bonus-popup">BONUS +15</div>
<div id="hit-popup">+10</div>

<div id="game-over">
  <h1>Round Over</h1>
  <div class="final-score" id="final-score">0</div>
  <div class="breakdown" id="breakdown"></div>
  <button id="replay-btn" onclick="startGame()">Play Again</button>
</div>

<script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js"
  }
}
</script>
<script type="module">
import * as THREE from 'three';

// --- Touch Detection ---
const isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
if (isTouchDevice) {
  document.getElementById('start-btn').textContent = 'Tap to Play';
  document.getElementById('replay-btn').textContent = 'Tap to Play Again';
}

// --- Game State ---
const TOTAL_ARROWS = 15;
let arrowsLeft, score, hits, bullseyes, gameActive, bestScore = 0;
let yaw = 0, pitch = 0;
const arrows = [];
const targets = [];
const movingTargets = [];
let nextMovingTargetTime = 0;

// Phase 1: Draw mechanic state
let isDrawing = false;
let drawStartTime = 0;
const DRAW_MAX_TIME = 1.5;
let nockedArrow = null;

// Phase 2: Wind + Difficulty
let wind = new THREE.Vector3(0, 0, 0);
let windStrengthRange = 3;
let roundNumber = 0;
let difficultyMultiplier = 1;

// Phase 3: Visual polish
const trailLines = [];
const stuckArrows = [];
const hitMarkers = [];
const clouds = [];
let slowMoActive = false;
let slowMoStartTime = 0;
const SLOWMO_DURATION = 2.0;

// Phase 4: Touch state
let touchId = null;
let touchStartX = 0, touchStartY = 0;

// --- Three.js Setup ---
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(70, innerWidth / innerHeight, 0.1, 500);
camera.position.set(0, 1.6, 0);

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(innerWidth, innerHeight);
renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFSoftShadowMap;
renderer.toneMapping = THREE.ACESFilmicToneMapping;
renderer.toneMappingExposure = 1.2;
document.body.appendChild(renderer.domElement);

// --- Sky ---
const skyGeo = new THREE.SphereGeometry(200, 32, 32);
const skyMat = new THREE.ShaderMaterial({
  side: THREE.BackSide,
  uniforms: {
    topColor: { value: new THREE.Color(0x0055aa) },
    bottomColor: { value: new THREE.Color(0x88ccff) },
    offset: { value: 20 },
    exponent: { value: 0.4 }
  },
  vertexShader: `
    varying vec3 vWorldPosition;
    void main() {
      vec4 worldPos = modelMatrix * vec4(position, 1.0);
      vWorldPosition = worldPos.xyz;
      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    }
  `,
  fragmentShader: `
    uniform vec3 topColor;
    uniform vec3 bottomColor;
    uniform float offset;
    uniform float exponent;
    varying vec3 vWorldPosition;
    void main() {
      float h = normalize(vWorldPosition + offset).y;
      gl_FragColor = vec4(mix(bottomColor, topColor, max(pow(max(h, 0.0), exponent), 0.0)), 1.0);
    }
  `
});
scene.add(new THREE.Mesh(skyGeo, skyMat));

// --- Phase 3D: Animated Clouds ---
function createCloudCluster(x, y, z) {
  const group = new THREE.Group();
  const cloudMat = new THREE.MeshLambertMaterial({ color: 0xffffff, transparent: true, opacity: 0.85 });
  const numPuffs = 3 + Math.floor(Math.random() * 3);
  for (let i = 0; i < numPuffs; i++) {
    const puff = new THREE.Mesh(
      new THREE.SphereGeometry(1.5 + Math.random() * 2, 8, 8),
      cloudMat
    );
    puff.position.set(
      (Math.random() - 0.5) * 4,
      (Math.random() - 0.5) * 0.8,
      (Math.random() - 0.5) * 2
    );
    puff.scale.set(1, 0.4 + Math.random() * 0.3, 1);
    group.add(puff);
  }
  group.position.set(x, y, z);
  group.userData = { speed: 0.3 + Math.random() * 0.5 };
  scene.add(group);
  clouds.push(group);
  return group;
}

for (let i = 0; i < 6; i++) {
  createCloudCluster(
    (Math.random() - 0.5) * 140,
    25 + Math.random() * 15,
    -(20 + Math.random() * 60)
  );
}

// --- Lighting ---
const ambient = new THREE.AmbientLight(0x8899bb, 0.6);
scene.add(ambient);

const sun = new THREE.DirectionalLight(0xffeedd, 1.5);
sun.position.set(30, 40, 20);
sun.castShadow = true;
sun.shadow.mapSize.set(2048, 2048);
sun.shadow.camera.left = -50;
sun.shadow.camera.right = 50;
sun.shadow.camera.top = 50;
sun.shadow.camera.bottom = -50;
scene.add(sun);

// --- Ground ---
const groundGeo = new THREE.PlaneGeometry(200, 200);
const groundMat = new THREE.MeshLambertMaterial({ color: 0x3a7d2a });
const ground = new THREE.Mesh(groundGeo, groundMat);
ground.rotation.x = -Math.PI / 2;
ground.receiveShadow = true;
scene.add(ground);

// Dirt patch under player
const dirtGeo = new THREE.CircleGeometry(2, 32);
const dirtMat = new THREE.MeshLambertMaterial({ color: 0x8B7355 });
const dirt = new THREE.Mesh(dirtGeo, dirtMat);
dirt.rotation.x = -Math.PI / 2;
dirt.position.y = 0.01;
scene.add(dirt);

// --- Fence ---
function createFence() {
  const group = new THREE.Group();
  const postGeo = new THREE.CylinderGeometry(0.04, 0.04, 1.2, 6);
  const postMat = new THREE.MeshLambertMaterial({ color: 0x8B6914 });
  const railGeo = new THREE.BoxGeometry(2.5, 0.06, 0.04);
  for (let i = -20; i <= 20; i += 2.5) {
    const post = new THREE.Mesh(postGeo, postMat);
    post.position.set(i, 0.6, -3);
    post.castShadow = true;
    group.add(post);
  }
  for (let i = -18.75; i <= 18.75; i += 2.5) {
    const topRail = new THREE.Mesh(railGeo, postMat);
    topRail.position.set(i, 1.0, -3);
    group.add(topRail);
    const botRail = new THREE.Mesh(railGeo, postMat);
    botRail.position.set(i, 0.4, -3);
    group.add(botRail);
  }
  return group;
}
scene.add(createFence());

// --- Simple Trees ---
function createTree(x, z) {
  const group = new THREE.Group();
  const trunk = new THREE.Mesh(
    new THREE.CylinderGeometry(0.15, 0.2, 2, 8),
    new THREE.MeshLambertMaterial({ color: 0x6B4226 })
  );
  trunk.position.y = 1;
  trunk.castShadow = true;
  group.add(trunk);

  const leaves = new THREE.Mesh(
    new THREE.SphereGeometry(1.2, 8, 8),
    new THREE.MeshLambertMaterial({ color: 0x2d6b1e })
  );
  leaves.position.y = 2.5;
  leaves.castShadow = true;
  group.add(leaves);

  group.position.set(x, 0, z);
  return group;
}

for (let i = 0; i < 12; i++) {
  const side = Math.random() > 0.5 ? 1 : -1;
  const x = side * (10 + Math.random() * 15);
  const z = -(5 + Math.random() * 40);
  scene.add(createTree(x, z));
}

// --- Target Creation ---
function createTarget(distance, xOffset = 0) {
  const group = new THREE.Group();

  const post = new THREE.Mesh(
    new THREE.CylinderGeometry(0.08, 0.1, 2.4, 8),
    new THREE.MeshLambertMaterial({ color: 0x6B4226 })
  );
  post.position.y = 1.2;
  post.castShadow = true;
  group.add(post);

  const rings = [
    { radius: 1.4, color: 0xffffff },
    { radius: 1.12, color: 0x222222 },
    { radius: 0.84, color: 0x3399ff },
    { radius: 0.56, color: 0xff3333 },
    { radius: 0.28, color: 0xffdd00 },
  ];

  const targetFace = new THREE.Group();
  targetFace.name = 'targetFace';
  rings.forEach((ring, i) => {
    const geo = new THREE.CircleGeometry(ring.radius, 32);
    const mat = new THREE.MeshLambertMaterial({ color: ring.color, side: THREE.DoubleSide });
    const mesh = new THREE.Mesh(geo, mat);
    mesh.position.z = 0.001 * i;
    targetFace.add(mesh);
  });

  targetFace.position.set(0, 2.4, -0.05);
  group.add(targetFace);

  const boardGeo = new THREE.CylinderGeometry(1.5, 1.5, 0.12, 32);
  const board = new THREE.Mesh(
    boardGeo,
    new THREE.MeshLambertMaterial({ color: 0xc9a96e })
  );
  board.rotation.x = Math.PI / 2;
  board.position.set(0, 2.4, -0.1);
  board.castShadow = true;
  group.add(board);

  group.position.set(xOffset, 0, -distance);

  const canvas = document.createElement('canvas');
  canvas.width = 128;
  canvas.height = 64;
  const ctx = canvas.getContext('2d');
  ctx.fillStyle = '#fff';
  ctx.font = 'bold 36px sans-serif';
  ctx.textAlign = 'center';
  ctx.fillText(`${distance}m`, 64, 42);
  const tex = new THREE.CanvasTexture(canvas);
  const label = new THREE.Mesh(
    new THREE.PlaneGeometry(1, 0.5),
    new THREE.MeshBasicMaterial({ map: tex, transparent: true })
  );
  label.position.set(0, 4.2, 0);
  group.add(label);

  group.userData = { center: new THREE.Vector3(xOffset, 2.4, -distance), radius: 1.4, distance };
  scene.add(group);
  targets.push(group);
  return group;
}

createTarget(12, -3);
createTarget(22, 0);
createTarget(35, 3);

// --- Moving Target ---
function spawnMovingTarget() {
  const y = 2.5 + Math.random() * 3;
  const z = -(10 + Math.random() * 25);
  const startX = (Math.random() > 0.5 ? 1 : -1) * 20;
  const speed = (4 + Math.random() * 4) * difficultyMultiplier;
  const isBird = Math.random() > 0.5;

  const group = new THREE.Group();

  if (isBird) {
    const birdColor = 0x222222;
    const birdMat = new THREE.MeshLambertMaterial({ color: birdColor, side: THREE.DoubleSide });

    const body = new THREE.Mesh(
      new THREE.SphereGeometry(0.25, 10, 8),
      birdMat
    );
    body.scale.set(1, 0.7, 2);
    body.castShadow = true;
    group.add(body);

    const wingShape = new THREE.Shape();
    wingShape.moveTo(0, 0);
    wingShape.lineTo(-1, 0.15);
    wingShape.lineTo(-0.3, 0);
    wingShape.closePath();
    const wingGeo = new THREE.ShapeGeometry(wingShape);
    const leftWing = new THREE.Mesh(wingGeo, birdMat);
    leftWing.name = 'leftWing';
    leftWing.position.set(-0.1, 0.05, 0);
    group.add(leftWing);

    const rWingShape = new THREE.Shape();
    rWingShape.moveTo(0, 0);
    rWingShape.lineTo(1, 0.15);
    rWingShape.lineTo(0.3, 0);
    rWingShape.closePath();
    const rWingGeo = new THREE.ShapeGeometry(rWingShape);
    const rightWing = new THREE.Mesh(rWingGeo, birdMat);
    rightWing.name = 'rightWing';
    rightWing.position.set(0.1, 0.05, 0);
    group.add(rightWing);

    const tailShape = new THREE.Shape();
    tailShape.moveTo(0, 0);
    tailShape.lineTo(-0.2, 0.15);
    tailShape.lineTo(0.2, 0.15);
    tailShape.closePath();
    const tailGeo = new THREE.ShapeGeometry(tailShape);
    const tail = new THREE.Mesh(tailGeo, birdMat);
    tail.position.set(0, 0.05, 0.5);
    group.add(tail);

    group.rotation.y = startX > 0 ? Math.PI / 2 : -Math.PI / 2;

    group.position.set(startX, y, z);
    group.userData = {
      speed: speed * (startX > 0 ? -1 : 1),
      alive: true,
      startX,
      radius: 0.5,
      center: group.position,
      isBird: true
    };
  } else {
    const orb = new THREE.Mesh(
      new THREE.SphereGeometry(0.5, 16, 16),
      new THREE.MeshStandardMaterial({
        color: 0xff8800,
        emissive: 0xff4400,
        emissiveIntensity: 0.8,
        metalness: 0.3,
        roughness: 0.4
      })
    );
    orb.castShadow = true;
    group.add(orb);

    const glow = new THREE.Mesh(
      new THREE.SphereGeometry(0.3, 12, 12),
      new THREE.MeshBasicMaterial({ color: 0xffdd00 })
    );
    group.add(glow);

    const light = new THREE.PointLight(0xff6600, 2, 8);
    group.add(light);

    group.position.set(startX, y, z);
    group.userData = {
      speed: speed * (startX > 0 ? -1 : 1),
      alive: true,
      startX,
      radius: 0.5,
      center: group.position,
      isBird: false
    };
  }

  scene.add(group);
  movingTargets.push(group);
}

// --- Arrow Creation ---
function createArrow() {
  const group = new THREE.Group();

  const shaft = new THREE.Mesh(
    new THREE.CylinderGeometry(0.015, 0.015, 0.8, 6),
    new THREE.MeshLambertMaterial({ color: 0xc9a040 })
  );
  shaft.rotation.x = Math.PI / 2;
  shaft.position.z = -0.4;
  group.add(shaft);

  const tip = new THREE.Mesh(
    new THREE.ConeGeometry(0.03, 0.1, 6),
    new THREE.MeshLambertMaterial({ color: 0x888888 })
  );
  tip.rotation.x = -Math.PI / 2;
  tip.position.z = -0.85;
  group.add(tip);

  const fletchGeo = new THREE.BufferGeometry();
  const verts = new Float32Array([0,0,0, 0,0.06,0.15, 0,0,0.15]);
  fletchGeo.setAttribute('position', new THREE.BufferAttribute(verts, 3));
  const fletchMat = new THREE.MeshBasicMaterial({ color: 0xff2222, side: THREE.DoubleSide });
  for (let i = 0; i < 3; i++) {
    const fletch = new THREE.Mesh(fletchGeo, fletchMat);
    fletch.rotation.z = (i / 3) * Math.PI * 2;
    fletch.position.z = 0;
    group.add(fletch);
  }

  return group;
}

// --- Bow (visual, attached to camera) ---
function createBow() {
  const group = new THREE.Group();

  const curve = new THREE.QuadraticBezierCurve3(
    new THREE.Vector3(0, -0.5, 0),
    new THREE.Vector3(0.15, 0, 0),
    new THREE.Vector3(0, 0.5, 0)
  );
  const tubeGeo = new THREE.TubeGeometry(curve, 20, 0.015, 8, false);
  const bowMat = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
  const bowMesh = new THREE.Mesh(tubeGeo, bowMat);
  group.add(bowMesh);

  // Bowstring â€” 3-point line for draw animation
  const stringPositions = new Float32Array([
    0, -0.5, 0,
    0, 0, 0,
    0, 0.5, 0
  ]);
  const stringGeo = new THREE.BufferGeometry();
  stringGeo.setAttribute('position', new THREE.BufferAttribute(stringPositions, 3));
  const stringMat = new THREE.LineBasicMaterial({ color: 0xdddddd });
  const bowString = new THREE.Line(stringGeo, stringMat);
  bowString.name = 'bowString';
  group.add(bowString);

  group.position.set(0.4, -0.25, -0.6);
  group.rotation.z = -0.1;
  return group;
}

const bow = createBow();
camera.add(bow);
scene.add(camera);

// --- Phase 1: Draw Power Helper ---
function getDrawPower() {
  if (!isDrawing) return 0;
  const elapsed = (performance.now() - drawStartTime) / 1000;
  return Math.min(elapsed / DRAW_MAX_TIME, 1);
}

function updateBowstring(power) {
  const bowString = bow.getObjectByName('bowString');
  if (!bowString) return;
  const posAttr = bowString.geometry.getAttribute('position');
  // Middle point pulls back on Z axis
  posAttr.setZ(1, power * 0.25);
  posAttr.needsUpdate = true;
}

function showNockedArrow(show) {
  if (show && !nockedArrow) {
    nockedArrow = createArrow();
    nockedArrow.scale.setScalar(0.7);
    nockedArrow.position.set(0.4, -0.25, -0.6);
    nockedArrow.rotation.set(0, 0, -0.1);
    camera.add(nockedArrow);
  } else if (!show && nockedArrow) {
    camera.remove(nockedArrow);
    nockedArrow = null;
  }
}

function updateNockedArrowPosition(power) {
  if (nockedArrow) {
    nockedArrow.position.z = -0.6 + power * 0.25;
  }
}

function updatePowerBar(power) {
  const container = document.getElementById('power-bar-container');
  const fill = document.getElementById('power-bar-fill');
  if (power > 0) {
    container.style.display = 'block';
    fill.style.width = (power * 100) + '%';
    // Green -> yellow -> red gradient
    if (power < 0.5) {
      const t = power / 0.5;
      const r = Math.round(255 * t);
      const g = 200;
      fill.style.background = `rgb(${r},${g},0)`;
    } else {
      const t = (power - 0.5) / 0.5;
      const g = Math.round(200 * (1 - t));
      fill.style.background = `rgb(255,${g},0)`;
    }
  } else {
    container.style.display = 'none';
  }
}

// --- Phase 2: Wind System ---
function randomizeWind() {
  const angle = Math.random() * Math.PI * 2;
  const strength = Math.random() * windStrengthRange * difficultyMultiplier;
  wind.set(Math.cos(angle) * strength, 0, Math.sin(angle) * strength);
  drawWindCompass();
}

function drawWindCompass() {
  const canvas = document.getElementById('wind-compass');
  const ctx = canvas.getContext('2d');
  const cx = 30, cy = 30, r = 24;
  ctx.clearRect(0, 0, 60, 60);

  // Background circle
  ctx.beginPath();
  ctx.arc(cx, cy, r, 0, Math.PI * 2);
  ctx.fillStyle = 'rgba(0,0,0,0.4)';
  ctx.fill();
  ctx.strokeStyle = 'rgba(255,255,255,0.3)';
  ctx.lineWidth = 1;
  ctx.stroke();

  // Wind arrow
  const strength = Math.sqrt(wind.x * wind.x + wind.z * wind.z);
  if (strength > 0.2) {
    const angle = Math.atan2(wind.x, -wind.z);
    const len = Math.min(strength / (windStrengthRange * difficultyMultiplier), 1) * (r - 4);
    const ex = cx + Math.sin(angle) * len;
    const ey = cy - Math.cos(angle) * len;

    ctx.beginPath();
    ctx.moveTo(cx, cy);
    ctx.lineTo(ex, ey);
    ctx.strokeStyle = '#ff8833';
    ctx.lineWidth = 2.5;
    ctx.stroke();

    // Arrowhead
    const headLen = 6;
    const ha = angle + Math.PI;
    ctx.beginPath();
    ctx.moveTo(ex, ey);
    ctx.lineTo(ex + Math.sin(ha - 0.5) * headLen, ey - Math.cos(ha - 0.5) * headLen);
    ctx.moveTo(ex, ey);
    ctx.lineTo(ex + Math.sin(ha + 0.5) * headLen, ey - Math.cos(ha + 0.5) * headLen);
    ctx.stroke();
  } else {
    ctx.fillStyle = 'rgba(255,255,255,0.5)';
    ctx.beginPath();
    ctx.arc(cx, cy, 3, 0, Math.PI * 2);
    ctx.fill();
  }

  // Wind label
  const label = document.getElementById('wind-label');
  let desc;
  if (strength < 0.5) desc = 'Calm';
  else if (strength < 2) desc = 'Light';
  else if (strength < 4) desc = 'Moderate';
  else desc = 'Strong';
  label.textContent = `Wind: ${desc}`;
}

// --- Phase 3A: Arrow Trail ---
function createTrail(arrow) {
  const positions = new Float32Array(15 * 3);
  const geo = new THREE.BufferGeometry();
  geo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
  geo.setDrawRange(0, 0);
  const mat = new THREE.LineBasicMaterial({ color: 0xffffcc, transparent: true, opacity: 0.4 });
  const line = new THREE.Line(geo, mat);
  scene.add(line);
  const trail = { line, points: [], arrow };
  trailLines.push(trail);
  return trail;
}

function updateTrails() {
  for (let i = trailLines.length - 1; i >= 0; i--) {
    const trail = trailLines[i];
    const arrow = trail.arrow;
    if (!arrow.userData.alive && arrow.userData.age !== undefined) {
      // Arrow is dead, fade trail
      trail.line.material.opacity -= 0.02;
      if (trail.line.material.opacity <= 0) {
        scene.remove(trail.line);
        trailLines.splice(i, 1);
      }
      continue;
    }
    if (arrow.userData.alive) {
      trail.points.push(arrow.position.clone());
      if (trail.points.length > 15) trail.points.shift();
      const posAttr = trail.line.geometry.getAttribute('position');
      for (let j = 0; j < trail.points.length; j++) {
        posAttr.setXYZ(j, trail.points[j].x, trail.points[j].y, trail.points[j].z);
      }
      posAttr.needsUpdate = true;
      trail.line.geometry.setDrawRange(0, trail.points.length);
    }
  }
}

// --- Shoot (Phase 1: power-based) ---
function shoot(power) {
  if (!gameActive || arrowsLeft <= 0) return;
  arrowsLeft--;
  updateHUD();

  const arrow = createArrow();
  const dir = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
  const speed = 20 + 40 * power;
  arrow.position.copy(camera.position);
  arrow.quaternion.copy(camera.quaternion);
  arrow.userData = {
    velocity: dir.multiplyScalar(speed),
    alive: true,
    age: 0
  };
  scene.add(arrow);
  arrows.push(arrow);

  // Create trail
  createTrail(arrow);

  // Bow recoil
  bow.position.z = -0.5;
  setTimeout(() => { bow.position.z = -0.6; }, 100);

  // Wind: randomize after each shot
  randomizeWind();

  // Phase 3E: slow-mo on last arrow
  if (arrowsLeft <= 0) {
    slowMoActive = true;
    slowMoStartTime = performance.now() / 1000;
    document.getElementById('slowmo-vignette').style.opacity = '1';
  }
}

// --- Collision Detection ---
function checkHit(arrow) {
  const tip = arrow.position.clone().add(
    new THREE.Vector3(0, 0, -0.85).applyQuaternion(arrow.quaternion)
  );

  // Check static targets
  for (const target of targets) {
    const center = target.userData.center.clone();
    const dist = tip.distanceTo(center);
    if (dist < target.userData.radius) {
      arrow.userData.alive = false;
      const points = getTargetScore(dist, target.userData.radius);
      addScore(points, false);

      // Phase 3B: Stick arrow in target
      stickArrowInTarget(arrow, target, tip);

      // Phase 3C: Hit marker
      placeHitMarker(target, tip, dist, target.userData.radius);

      return true;
    }
  }

  // Check moving targets
  for (let i = movingTargets.length - 1; i >= 0; i--) {
    const mt = movingTargets[i];
    if (!mt.userData.alive) continue;
    const dist = tip.distanceTo(mt.position);
    if (dist < mt.userData.radius + 0.2) {
      arrow.userData.alive = false;
      mt.userData.alive = false;

      for (let j = 0; j < 12; j++) {
        const particle = new THREE.Mesh(
          new THREE.SphereGeometry(0.08, 6, 6),
          new THREE.MeshBasicMaterial({ color: 0xff8800 })
        );
        particle.position.copy(mt.position);
        particle.userData = {
          velocity: new THREE.Vector3(
            (Math.random() - 0.5) * 8,
            Math.random() * 6,
            (Math.random() - 0.5) * 8
          ),
          age: 0,
          isParticle: true
        };
        scene.add(particle);
        arrows.push(particle);
      }

      scene.remove(mt);
      movingTargets.splice(i, 1);
      addScore(15, true);
      return true;
    }
  }

  // Check ground hit
  if (tip.y <= 0.05) {
    arrow.userData.alive = false;
    return true;
  }

  return false;
}

// Phase 3B: Stick arrow in target
function stickArrowInTarget(arrow, target, tipWorld) {
  scene.remove(arrow);
  const localPos = target.worldToLocal(tipWorld.clone());
  // Nudge arrow tip into the target face
  localPos.z -= 0.15;
  arrow.position.copy(localPos);
  // Point arrow toward target face (negative Z in target space)
  arrow.quaternion.identity();
  target.add(arrow);
  stuckArrows.push({ arrow, target });
}

// Phase 3C: Hit marker on target
function placeHitMarker(target, tipWorld, dist, maxRadius) {
  const ratio = dist / maxRadius;
  let color;
  if (ratio < 0.22) color = 0xffdd00;      // bullseye gold
  else if (ratio < 0.42) color = 0xff3333;  // red
  else if (ratio < 0.62) color = 0x3399ff;  // blue
  else if (ratio < 0.82) color = 0x222222;  // black
  else color = 0xffffff;                     // white

  const marker = new THREE.Mesh(
    new THREE.RingGeometry(0.03, 0.06, 16),
    new THREE.MeshBasicMaterial({ color, side: THREE.DoubleSide })
  );
  const localPos = target.worldToLocal(tipWorld.clone());
  localPos.z += 0.01;
  marker.position.copy(localPos);
  target.add(marker);
  hitMarkers.push({ marker, target });
}

function getTargetScore(dist, maxRadius) {
  const ratio = dist / maxRadius;
  if (ratio < 0.22) { bullseyes++; return 10; }
  if (ratio < 0.42) return 8;
  if (ratio < 0.62) return 6;
  if (ratio < 0.82) return 4;
  return 2;
}

function addScore(points, isBonus) {
  score += points;
  hits++;
  document.getElementById('score').textContent = score;

  if (isBonus) {
    showPopup('bonus-popup', 'BONUS +15');
  } else {
    showPopup('hit-popup', `+${points}`);
  }
}

function showPopup(id, text) {
  const el = document.getElementById(id);
  el.textContent = text;
  el.style.opacity = '1';
  setTimeout(() => { el.style.opacity = '0'; }, 800);
}

// --- HUD ---
function updateHUD() {
  const container = document.getElementById('arrows-left');
  container.innerHTML = '';
  const wrapper = document.createElement('div');
  wrapper.className = 'arrow-icons';
  for (let i = 0; i < TOTAL_ARROWS; i++) {
    const icon = document.createElement('div');
    icon.className = 'arrow-icon' + (i >= arrowsLeft ? ' used' : '');
    wrapper.appendChild(icon);
  }
  container.appendChild(wrapper);
}

// --- Game Flow ---
function startGame() {
  document.getElementById('start-screen').style.display = 'none';
  document.getElementById('game-over').style.display = 'none';

  if (!isTouchDevice) {
    document.body.requestPointerLock();
  } else {
    // Request fullscreen + landscape on mobile
    const el = document.documentElement;
    if (el.requestFullscreen) {
      el.requestFullscreen().catch(() => {});
    } else if (el.webkitRequestFullscreen) {
      el.webkitRequestFullscreen();
    }
    try {
      screen.orientation.lock('landscape').catch(() => {});
    } catch(e) {}
  }

  // Clean up old arrows + trails + stuck arrows + hit markers
  arrows.forEach(a => scene.remove(a));
  arrows.length = 0;
  movingTargets.forEach(mt => scene.remove(mt));
  movingTargets.length = 0;
  trailLines.forEach(t => scene.remove(t.line));
  trailLines.length = 0;
  stuckArrows.forEach(sa => sa.target.remove(sa.arrow));
  stuckArrows.length = 0;
  hitMarkers.forEach(hm => hm.target.remove(hm.marker));
  hitMarkers.length = 0;

  // Reset draw state
  isDrawing = false;
  drawStartTime = 0;
  showNockedArrow(false);
  updatePowerBar(0);
  updateBowstring(0);

  // Reset slow-mo
  slowMoActive = false;
  document.getElementById('slowmo-vignette').style.opacity = '0';

  arrowsLeft = TOTAL_ARROWS;
  score = 0;
  hits = 0;
  bullseyes = 0;
  gameActive = true;
  yaw = 0;
  pitch = 0;
  nextMovingTargetTime = performance.now() + 3000;

  // Phase 2: Difficulty progression
  roundNumber++;
  difficultyMultiplier = 1 + (roundNumber - 1) * 0.2;
  windStrengthRange = 3;

  document.getElementById('score').textContent = '0';
  document.getElementById('best').textContent = `Best: ${bestScore}`;
  document.getElementById('round-display').textContent = `Round ${roundNumber}`;
  updateHUD();
  randomizeWind();
}

function endGame() {
  gameActive = false;
  if (!isTouchDevice) {
    document.exitPointerLock();
  }

  // Reset draw
  isDrawing = false;
  showNockedArrow(false);
  updatePowerBar(0);
  updateBowstring(0);

  // End slow-mo
  slowMoActive = false;
  document.getElementById('slowmo-vignette').style.opacity = '0';

  if (score > bestScore) bestScore = score;

  document.getElementById('final-score').textContent = score;
  document.getElementById('breakdown').innerHTML =
    `${hits}/${TOTAL_ARROWS} hits  |  ${bullseyes} bullseyes  |  Best: ${bestScore}<br>Round ${roundNumber}  |  Difficulty: x${difficultyMultiplier.toFixed(1)}`;
  document.getElementById('game-over').style.display = 'flex';
}

window.startGame = startGame;

// --- Input: Desktop (gated behind !isTouchDevice) ---
if (!isTouchDevice) {
  document.addEventListener('mousemove', (e) => {
    if (document.pointerLockElement && gameActive) {
      yaw -= e.movementX * 0.002;
      pitch -= e.movementY * 0.002;
      pitch = Math.max(-Math.PI / 3, Math.min(Math.PI / 3, pitch));
    }
  });

  // Phase 1: mousedown to start draw, mouseup to fire
  document.addEventListener('mousedown', (e) => {
    if (e.button !== 0) return;
    if (!document.pointerLockElement && gameActive) {
      document.body.requestPointerLock();
      return;
    }
    if (document.pointerLockElement && gameActive && arrowsLeft > 0 && !slowMoActive) {
      isDrawing = true;
      drawStartTime = performance.now();
      showNockedArrow(true);
    }
  });

  document.addEventListener('mouseup', (e) => {
    if (e.button !== 0) return;
    if (isDrawing && gameActive) {
      const power = getDrawPower();
      isDrawing = false;
      showNockedArrow(false);
      updatePowerBar(0);
      updateBowstring(0);
      if (power > 0.05) {
        shoot(power);
      }
    }
  });

  document.addEventListener('keydown', (e) => {
    if (e.key === 'Escape' && gameActive) {
      // Allow pointer unlock
    }
  });

  // Re-lock pointer on click if game active
  document.addEventListener('click', () => {
    if (!document.pointerLockElement && gameActive) {
      document.body.requestPointerLock();
    }
  });
}

// --- Input: Mobile Touch Controls (Phase 4) ---
if (isTouchDevice) {
  document.addEventListener('touchstart', (e) => {
    if (!gameActive) return;
    e.preventDefault();
    if (touchId !== null) return;
    const touch = e.changedTouches[0];
    touchId = touch.identifier;
    touchStartX = touch.clientX;
    touchStartY = touch.clientY;

    // Start draw
    if (arrowsLeft > 0 && !slowMoActive) {
      isDrawing = true;
      drawStartTime = performance.now();
      showNockedArrow(true);
    }
  }, { passive: false });

  document.addEventListener('touchmove', (e) => {
    if (!gameActive) return;
    e.preventDefault();
    for (const touch of e.changedTouches) {
      if (touch.identifier === touchId) {
        const dx = touch.clientX - touchStartX;
        const dy = touch.clientY - touchStartY;
        yaw -= dx * 0.004;
        pitch -= dy * 0.004;
        pitch = Math.max(-Math.PI / 3, Math.min(Math.PI / 3, pitch));
        touchStartX = touch.clientX;
        touchStartY = touch.clientY;
      }
    }
  }, { passive: false });

  document.addEventListener('touchend', (e) => {
    if (!gameActive) return;
    e.preventDefault();
    for (const touch of e.changedTouches) {
      if (touch.identifier === touchId) {
        touchId = null;
        if (isDrawing) {
          const power = getDrawPower();
          isDrawing = false;
          showNockedArrow(false);
          updatePowerBar(0);
          updateBowstring(0);
          if (power > 0.05) {
            shoot(power);
          }
        }
      }
    }
  }, { passive: false });

  document.addEventListener('touchcancel', (e) => {
    touchId = null;
    isDrawing = false;
    showNockedArrow(false);
    updatePowerBar(0);
    updateBowstring(0);
  });
}

// --- Resize ---
window.addEventListener('resize', () => {
  camera.aspect = innerWidth / innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
});

// --- Game Loop ---
const clock = new THREE.Clock();
const gravity = new THREE.Vector3(0, -9.81, 0);

function animate() {
  requestAnimationFrame(animate);
  let dt = Math.min(clock.getDelta(), 0.05);
  const now = performance.now();
  const nowSec = now / 1000;

  // Phase 3E: Slow-mo
  if (slowMoActive) {
    const elapsed = nowSec - slowMoStartTime;
    if (elapsed > SLOWMO_DURATION) {
      slowMoActive = false;
      document.getElementById('slowmo-vignette').style.opacity = '0';
      endGame();
      return;
    }
    dt *= 0.2;
  }

  // Camera rotation
  const euler = new THREE.Euler(pitch, yaw, 0, 'YXZ');
  camera.quaternion.setFromEuler(euler);

  // Phase 1: Update draw visuals
  if (isDrawing) {
    const power = getDrawPower();
    updatePowerBar(power);
    updateBowstring(power);
    updateNockedArrowPosition(power);
  }

  // Update arrows
  for (let i = arrows.length - 1; i >= 0; i--) {
    const arrow = arrows[i];

    // Handle particles
    if (arrow.userData.isParticle) {
      arrow.userData.age += dt;
      if (arrow.userData.age > 1) {
        scene.remove(arrow);
        arrows.splice(i, 1);
        continue;
      }
      arrow.userData.velocity.add(gravity.clone().multiplyScalar(dt));
      arrow.position.add(arrow.userData.velocity.clone().multiplyScalar(dt));
      arrow.material.opacity = 1 - arrow.userData.age;
      arrow.material.transparent = true;
      arrow.scale.setScalar(1 - arrow.userData.age * 0.5);
      continue;
    }

    if (!arrow.userData.alive) continue;

    arrow.userData.age += dt;
    if (arrow.userData.age > 5) {
      arrow.userData.alive = false;
      scene.remove(arrow);
      arrows.splice(i, 1);
      continue;
    }

    // Physics: gravity + wind
    arrow.userData.velocity.add(gravity.clone().multiplyScalar(dt));
    arrow.userData.velocity.add(wind.clone().multiplyScalar(dt));
    arrow.position.add(arrow.userData.velocity.clone().multiplyScalar(dt));

    // Orient arrow along velocity
    const dir = arrow.userData.velocity.clone().normalize();
    const quat = new THREE.Quaternion();
    quat.setFromUnitVectors(new THREE.Vector3(0, 0, -1), dir);
    arrow.quaternion.copy(quat);

    // Check collisions
    if (checkHit(arrow)) {
      if (!arrow.userData.alive) {
        // Arrow sticks (handled in checkHit)
      }
    }
  }

  // Update trails
  updateTrails();

  // Spawn moving targets (difficulty scales spawn interval)
  if (gameActive && now > nextMovingTargetTime && !slowMoActive) {
    spawnMovingTarget();
    const baseInterval = 3000 + Math.random() * 3000;
    nextMovingTargetTime = now + baseInterval / difficultyMultiplier;
  }

  // Update moving targets
  for (let i = movingTargets.length - 1; i >= 0; i--) {
    const mt = movingTargets[i];
    mt.position.x += mt.userData.speed * dt;
    mt.position.y += Math.sin(now * 0.002 + i) * 0.003;

    if (mt.userData.isBird) {
      const flapAngle = Math.sin(now * 0.01) * 0.6;
      mt.traverse((child) => {
        if (child.name === 'leftWing') child.rotation.x = flapAngle;
        if (child.name === 'rightWing') child.rotation.x = -flapAngle;
      });
    } else {
      mt.rotation.y += dt * 2;
    }

    if (Math.abs(mt.position.x) > 25) {
      scene.remove(mt);
      movingTargets.splice(i, 1);
    }
  }

  // Phase 3D: Animate clouds
  for (const cloud of clouds) {
    cloud.position.x += cloud.userData.speed * dt;
    if (cloud.position.x > 80) cloud.position.x = -80;
    if (cloud.position.x < -80) cloud.position.x = 80;
  }

  renderer.render(scene, camera);
}

animate();
</script>
</body>
</html>
